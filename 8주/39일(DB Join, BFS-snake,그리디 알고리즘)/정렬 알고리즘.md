# 정렬 알고리즘





### 선택 정렬

- 처리안된 데이터중 제일 작은데이터를 맨앞데이터와 바꾸는걸 반복하기.

  ```python
  for i in range(len(list_)):
      min_ = i
      for j in range(i + 1, len(list_)):
          if list_[min_] > list_[j]:
              min_ = j
      list[i], list[min_] = list[min_], list[i] #스왑
  print(list_)
  
  이중 for문을 사용하니, O(N^2) 이다.
  ```





### 삽입 정렬

- 처리안된 데이터를 하나씩 골라 적절한 위치에 삽입. 
- 선택 정렬보다 구현힘들지만 속도가 빠름

```python
for i in range(1, len(list_)): #두번쨰 원소부터.
    for j in range(i, 0, -1): #인덱스 i부터 0까지 1씩 감소해가기
        if list_[j] < list_[j - 1]:			#한칸씩 왼쪽으로 이동하는데, j번쨰 원소가 더 작으면 스왑해줌.
            list_[j], list_[j - 1] = list_[j - 1], list_[j]
        else:		#자기보다 작은 데이터를 만나면 바꿈
            break
            

 이중 for문을 사용하므로 O(N^2) 인데, 이미 거의 정렬되었다면 O(N) 까지 줄어듬.
```





### 퀵 정렬

- 기준 데이터를 설정하고, 그 기준보다 큰데이터와 작은데이터의 위치를 바꾸는법. 제일 많이사용됨.
- 첫째 데이터를 기준데이터(피봇)로 설정함. 
- 피벗데이터를 기준으로 좌우 파티션이 이뤄지고, 그걸 또 재귀적으로 퀵정렬을 하는식... 반복하면 끝남.
- 이렇게 하면 O(NlogN (밑이 2인)) 의 속도가 나옴! 최악은 O(N^2) < 피벗을 제일작은원소로 잡고 시작했을때..

```python

def quicksort(list_, start, end):
    if start >= end: # 원소가 1개인 경우 종료
        return
    privot = start # 피벗은 첫쨰 원소
    left = start + 1
    right = end
    while (left <= right):
        while (left <= end and list_[left] <= list_[pivot]):
            left += 1
        while (right > start and list_[right] >= list_[pivot]):
            right -= 1
        if (left > right):
            list_[right], list[pivot] = list_[pivot], list_[right]
        else:
            list_[left], list_[right] = list_[right], list_[left]
    quicksort(list_ start, right - 1)
	quicksort(list_, right + 1, end)
    
quicksort(list_, 0, len(list_) - 1)
print(list_)
```

