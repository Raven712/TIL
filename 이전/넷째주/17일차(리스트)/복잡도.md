# 복잡도?



- 복잡도 낮은 알고리즘이 뭘까
- 시간이 얼마 안걸리는 알고리즘 !!!  
  - 기본연산이 몇번일어나는지를 보는것. 



- for 문에선,  in 뒤의 변수의 길이에 따라(n이라고 하자) 시간복잡도가 결정됨



- 시간복잡도 : 
  - 빅오노테이션으로 확인 가능 .. ?
  - 3n +2 와 3n^2+2n +1 



## 빅오 표기법

- n이 무한으로 간다 생각하고 최고차항만 남기고 계수 상수 다 제거
  - 위의 예 : O(n)과 O(n^2) 만 남음

- 빅오 함수의 크기비교
  - O(1) < O(log n)< O(n) < O(nlogn) < O(n^2) < O(2^n)

- O(1) : 단순 산술 계산(사칙연산), 상수복잡도라고 함
- O(log N) : 크기 N인 리스트를 반절씩 순회 --> 
  - 이진탐색
- O(N) :크기 N인 리스트를 순회 -->
  -  1중 for문
- O(NlogN) :  크기 N인 리스트를 반절씩 탐색 * 순회
  - 성능이 좋은 sort
- O(N^2) : 크기 M, N인 이중 리스트를 순회
  - 이중 for문
- O(2^n) : 크기 N집합의 부분 집합
- O(N!) : 최악



-- > 결국 초심자 입장에선 반복문 개수부터 줄이는쪽으로..

​	그러니까 결국 수 합구하기면 그냥 애초에 n(n+1)/2를 집어넣는것 << 복잡도 매우줄어듬. 상수복잡도가 나옴 (다 더하면 for문의 복잡도가 나오는데)

- sort() 함수도 은근 시간복잡도가 높음 . nlogn 급
- insert[a:b] -> 복잡도 N (처음부터 끝까지 일단 다 봐야해서)
- remove pop 이런거 전부다 그럼 