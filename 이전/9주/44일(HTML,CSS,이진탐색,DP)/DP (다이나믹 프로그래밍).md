# DP (다이나믹 프로그래밍)

- 메모리를 적절히 사용해 수행시간 효율성을 늘리는 방법.
- 이미 계산된 결과는 별도의 메모리 영역에 저장 . 다시 계산 안하도록 함
- 탑다운, 바텀 업으로 구성됨 (방식?)



- 동적이다?
  - 일반 프로그래밍에선 프로그램 실행도중 실행에 필요한 메모리를 할당하는 기법이라고 하는데, 여기선 그냥 의미가 없는 단어,,,



- 특정 조건을 만족해야 사용가능
  - 최적 부분 구조
    - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제 해결 가능
  - 중복되는 부분 문제
    - 동일한 작은 문제를 반복적으로 해결해야함



- 대표적인 문제 : 피보나치 수열
  - "점화식" --> 인접한 항들 사이의 관계식.

```python
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)
print(fibo(n))
```

- 저렇게 재귀함수로 수열을 해결하면 지수 시간복잡도가 나타남.
  - 저렇게 피보나치 함수를 풀면, f(2), f(1)들이 매우많이 호출되게됨.
  - fibo(30) 이면 10억번의 연산이 필요함.. fibo(100) 은 .. ? --> 컴퓨터가 우주멸망할떄까지 계산해야됨



- DP로 푼다면?

  - 1. 사용조건 만족여부 확인하기

    - 최적 부분구조 (큰 문제를 작은 문제로 나눌수 있나)
    - 중복되는 부분 문제 ( 동일한 작은 문제를 반복적으로 해결 )



**메모이제이션**.

- 한번 계산된 결과를 메모리 공간에 메모하는 기법
  - 같은 문제를 다시 호출하면 메모한 결과를 가져옴
  - 캐싱이라고도 부름.



**탑다운 vs 바텀업**

- 탑다운은 재귀함수 이용함. 큰 문제를 해결하기 위해 작은문제를 해결하는것..(메모이제이션)
- 바텀업은 상향식. 반복문을 이용함. 전형적인 형태가 바텀업방식임.
  - 결과 저장용 리스트를  DP 테이블로 부름.



```python
# 탑다운 방식

d = [0] * 100 # 메모이제이션 하기위한 리스트

def fibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]

print(fibo(99))
```

```python
# 바텀업 방식
d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]
   
print(d[n])
```

